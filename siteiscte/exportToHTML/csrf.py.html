<html>
<head>
<title>csrf.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
csrf.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Cross Site Request Forgery Middleware. 
 
This module provides a middleware that implements protection 
against request forgeries from other sites. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">urllib</span><span class="s3">.</span><span class="s1">parse </span><span class="s2">import </span><span class="s1">urlparse</span>

<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">conf </span><span class="s2">import </span><span class="s1">settings</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">exceptions </span><span class="s2">import </span><span class="s1">DisallowedHost</span><span class="s3">, </span><span class="s1">ImproperlyConfigured</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">http </span><span class="s2">import </span><span class="s1">HttpHeaders</span><span class="s3">, </span><span class="s1">UnreadablePostError</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">urls </span><span class="s2">import </span><span class="s1">get_callable</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">cache </span><span class="s2">import </span><span class="s1">patch_vary_headers</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">crypto </span><span class="s2">import </span><span class="s1">constant_time_compare</span><span class="s3">, </span><span class="s1">get_random_string</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">deprecation </span><span class="s2">import </span><span class="s1">MiddlewareMixin</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">functional </span><span class="s2">import </span><span class="s1">cached_property</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">http </span><span class="s2">import </span><span class="s1">is_same_domain</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">log </span><span class="s2">import </span><span class="s1">log_response</span>
<span class="s2">from </span><span class="s1">django</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">regex_helper </span><span class="s2">import </span><span class="s1">_lazy_re_compile</span>

<span class="s1">logger </span><span class="s3">= </span><span class="s1">logging</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s4">&quot;django.security.csrf&quot;</span><span class="s3">)</span>
<span class="s5"># This matches if any character is not in CSRF_ALLOWED_CHARS.</span>
<span class="s1">invalid_token_chars_re </span><span class="s3">= </span><span class="s1">_lazy_re_compile</span><span class="s3">(</span><span class="s4">&quot;[^a-zA-Z0-9]&quot;</span><span class="s3">)</span>

<span class="s1">REASON_BAD_ORIGIN </span><span class="s3">= </span><span class="s4">&quot;Origin checking failed - %s does not match any trusted origins.&quot;</span>
<span class="s1">REASON_NO_REFERER </span><span class="s3">= </span><span class="s4">&quot;Referer checking failed - no Referer.&quot;</span>
<span class="s1">REASON_BAD_REFERER </span><span class="s3">= </span><span class="s4">&quot;Referer checking failed - %s does not match any trusted origins.&quot;</span>
<span class="s1">REASON_NO_CSRF_COOKIE </span><span class="s3">= </span><span class="s4">&quot;CSRF cookie not set.&quot;</span>
<span class="s1">REASON_CSRF_TOKEN_MISSING </span><span class="s3">= </span><span class="s4">&quot;CSRF token missing.&quot;</span>
<span class="s1">REASON_MALFORMED_REFERER </span><span class="s3">= </span><span class="s4">&quot;Referer checking failed - Referer is malformed.&quot;</span>
<span class="s1">REASON_INSECURE_REFERER </span><span class="s3">= (</span>
    <span class="s4">&quot;Referer checking failed - Referer is insecure while host is secure.&quot;</span>
<span class="s3">)</span>
<span class="s5"># The reason strings below are for passing to InvalidTokenFormat. They are</span>
<span class="s5"># phrases without a subject because they can be in reference to either the CSRF</span>
<span class="s5"># cookie or non-cookie token.</span>
<span class="s1">REASON_INCORRECT_LENGTH </span><span class="s3">= </span><span class="s4">&quot;has incorrect length&quot;</span>
<span class="s1">REASON_INVALID_CHARACTERS </span><span class="s3">= </span><span class="s4">&quot;has invalid characters&quot;</span>

<span class="s1">CSRF_SECRET_LENGTH </span><span class="s3">= </span><span class="s6">32</span>
<span class="s1">CSRF_TOKEN_LENGTH </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">CSRF_SECRET_LENGTH</span>
<span class="s1">CSRF_ALLOWED_CHARS </span><span class="s3">= </span><span class="s1">string</span><span class="s3">.</span><span class="s1">ascii_letters </span><span class="s3">+ </span><span class="s1">string</span><span class="s3">.</span><span class="s1">digits</span>
<span class="s1">CSRF_SESSION_KEY </span><span class="s3">= </span><span class="s4">&quot;_csrftoken&quot;</span>


<span class="s2">def </span><span class="s1">_get_failure_view</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Return the view to be used for CSRF rejections.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">get_callable</span><span class="s3">(</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_FAILURE_VIEW</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_get_new_csrf_string</span><span class="s3">():</span>
    <span class="s2">return </span><span class="s1">get_random_string</span><span class="s3">(</span><span class="s1">CSRF_SECRET_LENGTH</span><span class="s3">, </span><span class="s1">allowed_chars</span><span class="s3">=</span><span class="s1">CSRF_ALLOWED_CHARS</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_mask_cipher_secret</span><span class="s3">(</span><span class="s1">secret</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a 
    token by adding a mask and applying it to the secret. 
    &quot;&quot;&quot;</span>
    <span class="s1">mask </span><span class="s3">= </span><span class="s1">_get_new_csrf_string</span><span class="s3">()</span>
    <span class="s1">chars </span><span class="s3">= </span><span class="s1">CSRF_ALLOWED_CHARS</span>
    <span class="s1">pairs </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">((</span><span class="s1">chars</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">secret</span><span class="s3">), (</span><span class="s1">chars</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">mask</span><span class="s3">))</span>
    <span class="s1">cipher </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">chars</span><span class="s3">[(</span><span class="s1">x </span><span class="s3">+ </span><span class="s1">y</span><span class="s3">) % </span><span class="s1">len</span><span class="s3">(</span><span class="s1">chars</span><span class="s3">)] </span><span class="s2">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">pairs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">mask </span><span class="s3">+ </span><span class="s1">cipher</span>


<span class="s2">def </span><span class="s1">_unmask_cipher_token</span><span class="s3">(</span><span class="s1">token</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length 
    CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt 
    the second half to produce the original secret. 
    &quot;&quot;&quot;</span>
    <span class="s1">mask </span><span class="s3">= </span><span class="s1">token</span><span class="s3">[:</span><span class="s1">CSRF_SECRET_LENGTH</span><span class="s3">]</span>
    <span class="s1">token </span><span class="s3">= </span><span class="s1">token</span><span class="s3">[</span><span class="s1">CSRF_SECRET_LENGTH</span><span class="s3">:]</span>
    <span class="s1">chars </span><span class="s3">= </span><span class="s1">CSRF_ALLOWED_CHARS</span>
    <span class="s1">pairs </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">((</span><span class="s1">chars</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">token</span><span class="s3">), (</span><span class="s1">chars</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">mask</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">chars</span><span class="s3">[</span><span class="s1">x </span><span class="s3">- </span><span class="s1">y</span><span class="s3">] </span><span class="s2">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">pairs</span><span class="s3">)  </span><span class="s5"># Note negative values are ok</span>


<span class="s2">def </span><span class="s1">_add_new_csrf_cookie</span><span class="s3">(</span><span class="s1">request</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Generate a new random CSRF_COOKIE value, and add it to request.META.&quot;&quot;&quot;</span>
    <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">_get_new_csrf_string</span><span class="s3">()</span>
    <span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span>
        <span class="s3">{</span>
            <span class="s4">&quot;CSRF_COOKIE&quot;</span><span class="s3">: </span><span class="s1">csrf_secret</span><span class="s3">,</span>
            <span class="s4">&quot;CSRF_COOKIE_NEEDS_UPDATE&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">}</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">csrf_secret</span>


<span class="s2">def </span><span class="s1">get_token</span><span class="s3">(</span><span class="s1">request</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the CSRF token required for a POST form. The token is an 
    alphanumeric value. A new token is created if one is not already set. 
 
    A side effect of calling this function is to make the csrf_protect 
    decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie' 
    header to the outgoing response.  For this reason, you may need to use this 
    function lazily, as is done by the csrf context processor. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s4">&quot;CSRF_COOKIE&quot; </span><span class="s2">in </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">:</span>
        <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE&quot;</span><span class="s3">]</span>
        <span class="s5"># Since the cookie is being used, flag to send the cookie in</span>
        <span class="s5"># process_response() (even if the client already has it) in order to</span>
        <span class="s5"># renew the expiry timer.</span>
        <span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE_NEEDS_UPDATE&quot;</span><span class="s3">] = </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">_add_new_csrf_cookie</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_mask_cipher_secret</span><span class="s3">(</span><span class="s1">csrf_secret</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rotate_token</span><span class="s3">(</span><span class="s1">request</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Change the CSRF token in use for a request - should be done on login 
    for security purposes. 
    &quot;&quot;&quot;</span>
    <span class="s1">_add_new_csrf_cookie</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">InvalidTokenFormat</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">reason </span><span class="s3">= </span><span class="s1">reason</span>


<span class="s2">def </span><span class="s1">_check_token_format</span><span class="s3">(</span><span class="s1">token</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Raise an InvalidTokenFormat error if the token has an invalid length or 
    characters that aren't allowed. The token argument can be a CSRF cookie 
    secret or non-cookie CSRF token, and either masked or unmasked. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">token</span><span class="s3">) </span><span class="s2">not in </span><span class="s3">(</span><span class="s1">CSRF_TOKEN_LENGTH</span><span class="s3">, </span><span class="s1">CSRF_SECRET_LENGTH</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">InvalidTokenFormat</span><span class="s3">(</span><span class="s1">REASON_INCORRECT_LENGTH</span><span class="s3">)</span>
    <span class="s5"># Make sure all characters are in CSRF_ALLOWED_CHARS.</span>
    <span class="s2">if </span><span class="s1">invalid_token_chars_re</span><span class="s3">.</span><span class="s1">search</span><span class="s3">(</span><span class="s1">token</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">InvalidTokenFormat</span><span class="s3">(</span><span class="s1">REASON_INVALID_CHARACTERS</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_does_token_match</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">, </span><span class="s1">csrf_secret</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether the given CSRF token matches the given CSRF secret, after 
    unmasking the token if necessary. 
 
    This function assumes that the request_csrf_token argument has been 
    validated to have the correct length (CSRF_SECRET_LENGTH or 
    CSRF_TOKEN_LENGTH characters) and allowed characters, and that if it has 
    length CSRF_TOKEN_LENGTH, it is a masked secret. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Only unmask tokens that are exactly CSRF_TOKEN_LENGTH characters long.</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">) == </span><span class="s1">CSRF_TOKEN_LENGTH</span><span class="s3">:</span>
        <span class="s1">request_csrf_token </span><span class="s3">= </span><span class="s1">_unmask_cipher_token</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">) == </span><span class="s1">CSRF_SECRET_LENGTH</span>
    <span class="s2">return </span><span class="s1">constant_time_compare</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">, </span><span class="s1">csrf_secret</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">reason </span><span class="s3">= </span><span class="s1">reason</span>


<span class="s2">class </span><span class="s1">CsrfViewMiddleware</span><span class="s3">(</span><span class="s1">MiddlewareMixin</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Require a present and correct csrfmiddlewaretoken for POST requests that 
    have a CSRF cookie, and set an outgoing CSRF cookie. 
 
    This middleware should be used in conjunction with the {% csrf_token %} 
    template tag. 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">cached_property</span>
    <span class="s2">def </span><span class="s1">csrf_trusted_origins_hosts</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span>
            <span class="s1">urlparse</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">).</span><span class="s1">netloc</span><span class="s3">.</span><span class="s1">lstrip</span><span class="s3">(</span><span class="s4">&quot;*&quot;</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_TRUSTED_ORIGINS</span>
        <span class="s3">]</span>

    <span class="s3">@</span><span class="s1">cached_property</span>
    <span class="s2">def </span><span class="s1">allowed_origins_exact</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s1">origin </span><span class="s2">for </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_TRUSTED_ORIGINS </span><span class="s2">if </span><span class="s4">&quot;*&quot; </span><span class="s2">not in </span><span class="s1">origin</span><span class="s3">}</span>

    <span class="s3">@</span><span class="s1">cached_property</span>
    <span class="s2">def </span><span class="s1">allowed_origin_subdomains</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        A mapping of allowed schemes to list of allowed netlocs, where all 
        subdomains of the netloc are allowed. 
        &quot;&quot;&quot;</span>
        <span class="s1">allowed_origin_subdomains </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">list</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">parsed </span><span class="s2">in </span><span class="s3">(</span>
            <span class="s1">urlparse</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">origin </span><span class="s2">in </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_TRUSTED_ORIGINS</span>
            <span class="s2">if </span><span class="s4">&quot;*&quot; </span><span class="s2">in </span><span class="s1">origin</span>
        <span class="s3">):</span>
            <span class="s1">allowed_origin_subdomains</span><span class="s3">[</span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">scheme</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">parsed</span><span class="s3">.</span><span class="s1">netloc</span><span class="s3">.</span><span class="s1">lstrip</span><span class="s3">(</span><span class="s4">&quot;*&quot;</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">allowed_origin_subdomains</span>

    <span class="s5"># The _accept and _reject methods currently only exist for the sake of the</span>
    <span class="s5"># requires_csrf_token decorator.</span>
    <span class="s2">def </span><span class="s1">_accept</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s5"># Avoid checking the request twice by adding a custom attribute to</span>
        <span class="s5"># request.  This will be relevant when both decorator and middleware</span>
        <span class="s5"># are used.</span>
        <span class="s1">request</span><span class="s3">.</span><span class="s1">csrf_processing_done </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_reject</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">):</span>
        <span class="s1">response </span><span class="s3">= </span><span class="s1">_get_failure_view</span><span class="s3">()(</span><span class="s1">request</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">=</span><span class="s1">reason</span><span class="s3">)</span>
        <span class="s1">log_response</span><span class="s3">(</span>
            <span class="s4">&quot;Forbidden (%s): %s&quot;</span><span class="s3">,</span>
            <span class="s1">reason</span><span class="s3">,</span>
            <span class="s1">request</span><span class="s3">.</span><span class="s1">path</span><span class="s3">,</span>
            <span class="s1">response</span><span class="s3">=</span><span class="s1">response</span><span class="s3">,</span>
            <span class="s1">request</span><span class="s3">=</span><span class="s1">request</span><span class="s3">,</span>
            <span class="s1">logger</span><span class="s3">=</span><span class="s1">logger</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">response</span>

    <span class="s2">def </span><span class="s1">_get_secret</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the CSRF secret originally associated with the request, or None 
        if it didn't have one. 
 
        If the CSRF_USE_SESSIONS setting is false, raises InvalidTokenFormat if 
        the request's secret has invalid characters or an invalid length. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_USE_SESSIONS</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">session</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">CSRF_SESSION_KEY</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ImproperlyConfigured</span><span class="s3">(</span>
                    <span class="s4">&quot;CSRF_USE_SESSIONS is enabled, but request.session is not &quot;</span>
                    <span class="s4">&quot;set. SessionMiddleware must appear before CsrfViewMiddleware &quot;</span>
                    <span class="s4">&quot;in MIDDLEWARE.&quot;</span>
                <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">COOKIES</span><span class="s3">[</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_NAME</span><span class="s3">]</span>
            <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s5"># This can raise InvalidTokenFormat.</span>
                <span class="s1">_check_token_format</span><span class="s3">(</span><span class="s1">csrf_secret</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">csrf_secret </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s5"># Django versions before 4.0 masked the secret before storing.</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">csrf_secret</span><span class="s3">) == </span><span class="s1">CSRF_TOKEN_LENGTH</span><span class="s3">:</span>
            <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">_unmask_cipher_token</span><span class="s3">(</span><span class="s1">csrf_secret</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">csrf_secret</span>

    <span class="s2">def </span><span class="s1">_set_csrf_cookie</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_USE_SESSIONS</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">request</span><span class="s3">.</span><span class="s1">session</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">CSRF_SESSION_KEY</span><span class="s3">) != </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE&quot;</span><span class="s3">]:</span>
                <span class="s1">request</span><span class="s3">.</span><span class="s1">session</span><span class="s3">[</span><span class="s1">CSRF_SESSION_KEY</span><span class="s3">] = </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE&quot;</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">response</span><span class="s3">.</span><span class="s1">set_cookie</span><span class="s3">(</span>
                <span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_NAME</span><span class="s3">,</span>
                <span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE&quot;</span><span class="s3">],</span>
                <span class="s1">max_age</span><span class="s3">=</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_AGE</span><span class="s3">,</span>
                <span class="s1">domain</span><span class="s3">=</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_DOMAIN</span><span class="s3">,</span>
                <span class="s1">path</span><span class="s3">=</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_PATH</span><span class="s3">,</span>
                <span class="s1">secure</span><span class="s3">=</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_SECURE</span><span class="s3">,</span>
                <span class="s1">httponly</span><span class="s3">=</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_HTTPONLY</span><span class="s3">,</span>
                <span class="s1">samesite</span><span class="s3">=</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_SAMESITE</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s5"># Set the Vary header since content varies with the CSRF cookie.</span>
            <span class="s1">patch_vary_headers</span><span class="s3">(</span><span class="s1">response</span><span class="s3">, (</span><span class="s4">&quot;Cookie&quot;</span><span class="s3">,))</span>

    <span class="s2">def </span><span class="s1">_origin_verified</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s1">request_origin </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;HTTP_ORIGIN&quot;</span><span class="s3">]</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">good_host </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">get_host</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">DisallowedHost</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">good_origin </span><span class="s3">= </span><span class="s4">&quot;%s://%s&quot; </span><span class="s3">% (</span>
                <span class="s4">&quot;https&quot; </span><span class="s2">if </span><span class="s1">request</span><span class="s3">.</span><span class="s1">is_secure</span><span class="s3">() </span><span class="s2">else </span><span class="s4">&quot;http&quot;</span><span class="s3">,</span>
                <span class="s1">good_host</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s2">if </span><span class="s1">request_origin </span><span class="s3">== </span><span class="s1">good_origin</span><span class="s3">:</span>
                <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">request_origin </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">allowed_origins_exact</span><span class="s3">:</span>
            <span class="s2">return True</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">parsed_origin </span><span class="s3">= </span><span class="s1">urlparse</span><span class="s3">(</span><span class="s1">request_origin</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">return False</span>
        <span class="s1">request_scheme </span><span class="s3">= </span><span class="s1">parsed_origin</span><span class="s3">.</span><span class="s1">scheme</span>
        <span class="s1">request_netloc </span><span class="s3">= </span><span class="s1">parsed_origin</span><span class="s3">.</span><span class="s1">netloc</span>
        <span class="s2">return </span><span class="s1">any</span><span class="s3">(</span>
            <span class="s1">is_same_domain</span><span class="s3">(</span><span class="s1">request_netloc</span><span class="s3">, </span><span class="s1">host</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">host </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">allowed_origin_subdomains</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">request_scheme</span><span class="s3">, ())</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_check_referer</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s1">referer </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;HTTP_REFERER&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">referer </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_NO_REFERER</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">referer </span><span class="s3">= </span><span class="s1">urlparse</span><span class="s3">(</span><span class="s1">referer</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_MALFORMED_REFERER</span><span class="s3">)</span>

        <span class="s5"># Make sure we have a valid URL for Referer.</span>
        <span class="s2">if </span><span class="s4">&quot;&quot; </span><span class="s2">in </span><span class="s3">(</span><span class="s1">referer</span><span class="s3">.</span><span class="s1">scheme</span><span class="s3">, </span><span class="s1">referer</span><span class="s3">.</span><span class="s1">netloc</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_MALFORMED_REFERER</span><span class="s3">)</span>

        <span class="s5"># Ensure that our Referer is also secure.</span>
        <span class="s2">if </span><span class="s1">referer</span><span class="s3">.</span><span class="s1">scheme </span><span class="s3">!= </span><span class="s4">&quot;https&quot;</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_INSECURE_REFERER</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span>
            <span class="s1">is_same_domain</span><span class="s3">(</span><span class="s1">referer</span><span class="s3">.</span><span class="s1">netloc</span><span class="s3">, </span><span class="s1">host</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">host </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">csrf_trusted_origins_hosts</span>
        <span class="s3">):</span>
            <span class="s2">return</span>
        <span class="s5"># Allow matching the configured cookie domain.</span>
        <span class="s1">good_referer </span><span class="s3">= (</span>
            <span class="s1">settings</span><span class="s3">.</span><span class="s1">SESSION_COOKIE_DOMAIN</span>
            <span class="s2">if </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_USE_SESSIONS</span>
            <span class="s2">else </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_COOKIE_DOMAIN</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">good_referer </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># If no cookie domain is configured, allow matching the current</span>
            <span class="s5"># host:port exactly if it's permitted by ALLOWED_HOSTS.</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s5"># request.get_host() includes the port.</span>
                <span class="s1">good_referer </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">get_host</span><span class="s3">()</span>
            <span class="s2">except </span><span class="s1">DisallowedHost</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_BAD_REFERER </span><span class="s3">% </span><span class="s1">referer</span><span class="s3">.</span><span class="s1">geturl</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">server_port </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">get_port</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">server_port </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">&quot;443&quot;</span><span class="s3">, </span><span class="s4">&quot;80&quot;</span><span class="s3">):</span>
                <span class="s1">good_referer </span><span class="s3">= </span><span class="s4">&quot;%s:%s&quot; </span><span class="s3">% (</span><span class="s1">good_referer</span><span class="s3">, </span><span class="s1">server_port</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">is_same_domain</span><span class="s3">(</span><span class="s1">referer</span><span class="s3">.</span><span class="s1">netloc</span><span class="s3">, </span><span class="s1">good_referer</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_BAD_REFERER </span><span class="s3">% </span><span class="s1">referer</span><span class="s3">.</span><span class="s1">geturl</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">_bad_token_message</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">, </span><span class="s1">token_source</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">token_source </span><span class="s3">!= </span><span class="s4">&quot;POST&quot;</span><span class="s3">:</span>
            <span class="s5"># Assume it is a settings.CSRF_HEADER_NAME value.</span>
            <span class="s1">header_name </span><span class="s3">= </span><span class="s1">HttpHeaders</span><span class="s3">.</span><span class="s1">parse_header_name</span><span class="s3">(</span><span class="s1">token_source</span><span class="s3">)</span>
            <span class="s1">token_source </span><span class="s3">= </span><span class="s4">f&quot;the </span><span class="s2">{</span><span class="s1">header_name</span><span class="s2">!r} </span><span class="s4">HTTP header&quot;</span>
        <span class="s2">return </span><span class="s4">f&quot;CSRF token from </span><span class="s2">{</span><span class="s1">token_source</span><span class="s2">} {</span><span class="s1">reason</span><span class="s2">}</span><span class="s4">.&quot;</span>

    <span class="s2">def </span><span class="s1">_check_token</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s5"># Access csrf_secret via self._get_secret() as rotate_token() may have</span>
        <span class="s5"># been called by an authentication middleware during the</span>
        <span class="s5"># process_request() phase.</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_secret</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">InvalidTokenFormat </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s4">f&quot;CSRF cookie </span><span class="s2">{</span><span class="s1">exc</span><span class="s3">.</span><span class="s1">reason</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">csrf_secret </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s5"># No CSRF cookie. For POST requests, we insist on a CSRF cookie,</span>
            <span class="s5"># and in this way we can avoid all CSRF attacks, including login</span>
            <span class="s5"># CSRF.</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_NO_CSRF_COOKIE</span><span class="s3">)</span>

        <span class="s5"># Check non-cookie token for match.</span>
        <span class="s1">request_csrf_token </span><span class="s3">= </span><span class="s4">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">request</span><span class="s3">.</span><span class="s1">method </span><span class="s3">== </span><span class="s4">&quot;POST&quot;</span><span class="s3">:</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">request_csrf_token </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">POST</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;csrfmiddlewaretoken&quot;</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">UnreadablePostError</span><span class="s3">:</span>
                <span class="s5"># Handle a broken connection before we've completed reading the</span>
                <span class="s5"># POST data. process_view shouldn't raise any exceptions, so</span>
                <span class="s5"># we'll ignore and serve the user a 403 (assuming they're still</span>
                <span class="s5"># listening, which they probably aren't because of the error).</span>
                <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">request_csrf_token </span><span class="s3">== </span><span class="s4">&quot;&quot;</span><span class="s3">:</span>
            <span class="s5"># Fall back to X-CSRFToken, to make things easier for AJAX, and</span>
            <span class="s5"># possible for PUT/DELETE.</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s5"># This can have length CSRF_SECRET_LENGTH or CSRF_TOKEN_LENGTH,</span>
                <span class="s5"># depending on whether the client obtained the token from</span>
                <span class="s5"># the DOM or the cookie (and if the cookie, whether the cookie</span>
                <span class="s5"># was masked or unmasked).</span>
                <span class="s1">request_csrf_token </span><span class="s3">= </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_HEADER_NAME</span><span class="s3">]</span>
            <span class="s2">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">REASON_CSRF_TOKEN_MISSING</span><span class="s3">)</span>
            <span class="s1">token_source </span><span class="s3">= </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">CSRF_HEADER_NAME</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">token_source </span><span class="s3">= </span><span class="s4">&quot;POST&quot;</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">_check_token_format</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">InvalidTokenFormat </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
            <span class="s1">reason </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_bad_token_message</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">.</span><span class="s1">reason</span><span class="s3">, </span><span class="s1">token_source</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">_does_token_match</span><span class="s3">(</span><span class="s1">request_csrf_token</span><span class="s3">, </span><span class="s1">csrf_secret</span><span class="s3">):</span>
            <span class="s1">reason </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_bad_token_message</span><span class="s3">(</span><span class="s4">&quot;incorrect&quot;</span><span class="s3">, </span><span class="s1">token_source</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">RejectRequest</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">process_request</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">csrf_secret </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_secret</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">InvalidTokenFormat</span><span class="s3">:</span>
            <span class="s1">_add_new_csrf_cookie</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">csrf_secret </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s5"># Use the same secret next time. If the secret was originally</span>
                <span class="s5"># masked, this also causes it to be replaced with the unmasked</span>
                <span class="s5"># form, but only in cases where the secret is already getting</span>
                <span class="s5"># saved anyways.</span>
                <span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE&quot;</span><span class="s3">] = </span><span class="s1">csrf_secret</span>

    <span class="s2">def </span><span class="s1">process_view</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">callback_args</span><span class="s3">, </span><span class="s1">callback_kwargs</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">request</span><span class="s3">, </span><span class="s4">&quot;csrf_processing_done&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
            <span class="s2">return None</span>

        <span class="s5"># Wait until request.META[&quot;CSRF_COOKIE&quot;] has been manipulated before</span>
        <span class="s5"># bailing out, so that get_token still works</span>
        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">, </span><span class="s4">&quot;csrf_exempt&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
            <span class="s2">return None</span>

        <span class="s5"># Assume that anything not defined as 'safe' by RFC 9110 needs protection</span>
        <span class="s2">if </span><span class="s1">request</span><span class="s3">.</span><span class="s1">method </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;GET&quot;</span><span class="s3">, </span><span class="s4">&quot;HEAD&quot;</span><span class="s3">, </span><span class="s4">&quot;OPTIONS&quot;</span><span class="s3">, </span><span class="s4">&quot;TRACE&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_accept</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">request</span><span class="s3">, </span><span class="s4">&quot;_dont_enforce_csrf_checks&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
            <span class="s5"># Mechanism to turn off CSRF checks for test suite. It comes after</span>
            <span class="s5"># the creation of CSRF cookies, so that everything else continues</span>
            <span class="s5"># to work exactly the same (e.g. cookies are sent, etc.), but</span>
            <span class="s5"># before any branches that call the _reject method.</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_accept</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>

        <span class="s5"># Reject the request if the Origin header doesn't match an allowed</span>
        <span class="s5"># value.</span>
        <span class="s2">if </span><span class="s4">&quot;HTTP_ORIGIN&quot; </span><span class="s2">in </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_origin_verified</span><span class="s3">(</span><span class="s1">request</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reject</span><span class="s3">(</span>
                    <span class="s1">request</span><span class="s3">, </span><span class="s1">REASON_BAD_ORIGIN </span><span class="s3">% </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;HTTP_ORIGIN&quot;</span><span class="s3">]</span>
                <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">request</span><span class="s3">.</span><span class="s1">is_secure</span><span class="s3">():</span>
            <span class="s5"># If the Origin header wasn't provided, reject HTTPS requests if</span>
            <span class="s5"># the Referer header doesn't match an allowed value.</span>
            <span class="s5">#</span>
            <span class="s5"># Suppose user visits http://example.com/</span>
            <span class="s5"># An active network attacker (man-in-the-middle, MITM) sends a</span>
            <span class="s5"># POST form that targets https://example.com/detonate-bomb/ and</span>
            <span class="s5"># submits it via JavaScript.</span>
            <span class="s5">#</span>
            <span class="s5"># The attacker will need to provide a CSRF cookie and token, but</span>
            <span class="s5"># that's no problem for a MITM and the session-independent secret</span>
            <span class="s5"># we're using. So the MITM can circumvent the CSRF protection. This</span>
            <span class="s5"># is true for any HTTP connection, but anyone using HTTPS expects</span>
            <span class="s5"># better! For this reason, for https://example.com/ we need</span>
            <span class="s5"># additional protection that treats http://example.com/ as</span>
            <span class="s5"># completely untrusted. Under HTTPS, Barth et al. found that the</span>
            <span class="s5"># Referer header is missing for same-domain requests in only about</span>
            <span class="s5"># 0.2% of cases or less, so we can use strict Referer checking.</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_referer</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>
            <span class="s2">except </span><span class="s1">RejectRequest </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reject</span><span class="s3">(</span><span class="s1">request</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">reason</span><span class="s3">)</span>

        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_token</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">RejectRequest </span><span class="s2">as </span><span class="s1">exc</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reject</span><span class="s3">(</span><span class="s1">request</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">.</span><span class="s1">reason</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_accept</span><span class="s3">(</span><span class="s1">request</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">process_response</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">response</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;CSRF_COOKIE_NEEDS_UPDATE&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_csrf_cookie</span><span class="s3">(</span><span class="s1">request</span><span class="s3">, </span><span class="s1">response</span><span class="s3">)</span>
            <span class="s5"># Unset the flag to prevent _set_csrf_cookie() from being</span>
            <span class="s5"># unnecessarily called again in process_response() by other</span>
            <span class="s5"># instances of CsrfViewMiddleware. This can happen e.g. when both a</span>
            <span class="s5"># decorator and middleware are used. However,</span>
            <span class="s5"># CSRF_COOKIE_NEEDS_UPDATE is still respected in subsequent calls</span>
            <span class="s5"># e.g. in case rotate_token() is called in process_response() later</span>
            <span class="s5"># by custom middleware but before those subsequent calls.</span>
            <span class="s1">request</span><span class="s3">.</span><span class="s1">META</span><span class="s3">[</span><span class="s4">&quot;CSRF_COOKIE_NEEDS_UPDATE&quot;</span><span class="s3">] = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">response</span>
</pre>
</body>
</html>